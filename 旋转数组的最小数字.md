### 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

### 解析

可以暴力法,直接遍历一遍数组,找到最小的,时间复杂度为O(n)

旋转之后的数组其实可以划分为两个排序的子数组,而且前面子数组的元素都大于等于后面子数组的元素,而且最小的元素正好是这两个子数组的分界线,因此我们可以试着用二分查找法的思路来寻找这个最小的元素

我们用两个指针分别指向数组的第一个元素和最后一个元素,按照旋转的规则,第一个元素应该是大于或者等于最后一个元素的,然后我们找到数组中间的元素,如果中间元素位于前面的递增子数组,那么它应该大于等于第一个指针指向的元素,此时最小的元素应该位于该中间元素的后面,把第一个指针指向该中间元素,查找范围缩小一半,且移动后第一个指针仍然位于前面的递增子数组. 同样的,如果中间元素位于后面的递增子数组,那么中间元素就应该小于等于第二个指针指向的元素, 接下来我们可以把第二个指针指向中间元素,查找范围也会缩小一般,且移动后第二个指针仍然位于后面的递增子数组.

不管是移动第一个指针还是移动第二个指针,查找范围都会缩小一半,然后用更新之后的两个指针重复做新一轮的查找

第一个指针总是指向前面递增数组的元素,第二个指针总是指向后面递增数组的元素,最终第一个指针将指向前面递增子数组的最后一个元素,而第二个指针会指向后面递增子数组的第一个元素,也就是说他们会指向两个相邻的元素,而第二个指针指向的就是数组中最小的元素,这就循环结束的条件.

但是当把排序数组前面的0个元素旋转到后面,即排序数组本身,这仍然是一个旋转数组,所以我们可以把最小元素初始化为数组第一个元素

还有一种特殊的情况:

比如 1,0,1,1,1  
在这个例子中,第一个指针第二个指针和中间元素都是1,我们无法判断中间的1是属于前面递增子数组还是属于后面的递增子数组,也就无法移动指针来缩小查找范围,此时我们只能使用顺序查找的方法

### 代码示例

```java
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length < 1) return 0;
        int index1 = 0, index2 = array.length - 1;
        //最小值初始化为数组第一个元素,如果旋转数组是数组本身,那么第一个元素就是最小的
        int min = array[index1];
        while (array[index1] >= array[index2]) {
            if (index2 - index1 == 1) {
            	//循环出口
                min = array[index2];
                break;
            }
            int mid = (index1 + index2) / 2;
            if (array[mid] == array[index1] && array[mid] == array[index2]) {
            	//无法缩小查找范围,使用顺序查找
                for (int i = index1; i <= index2; i++) {
                    if (array[i] < min) {
                        min = array[i];
                    }
                }
                break;
            }
            else if (array[index1] <= array[mid]) {
                index1 = mid;
            }else if (array[index2] >= array[mid]) {
                index2 = mid;
            }
        }
        return min;
    }
}
```